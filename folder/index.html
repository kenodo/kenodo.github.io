<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    
    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.1/pixi.min.js"></script>
<script src="bump.js"></script>

<script>
  let app = new PIXI.Application({ 
    width: 800, 
    height: 600,                       
    antialias: true, 
    transparent: false, 
    resolution: 1,
    backgroundColor:0x51b1cd,
    roundPixels: true
  }
);

//Add the canvas that Pixi automatically created for you to the HTML document
document.body.appendChild(app.view);

//load an image and run the `setup` function when it's done
PIXI.loader
  .add("s.jpg")
  .add("cat.png")
  .add("grass.png")
  .add("g.png")
  .add("back.png")
  .add("cat2.png")
  .load(setup);
    
PIXI.TRANSFORM_MODE.DEFAULT = PIXI.TRANSFORM_MODE.DYNAMIC;
    



//This `setup` function will run when the image has loaded
function setup() {
    var sand = new Array();
    
    var leftBlock = 0;
    var leftY = 256;
    var rightY = 256;
    var rightBlock=0;
    var catY=0;
    let pers = new PIXI.Container();
    let container = new PIXI.Container();
    var toDelete= [];
    
    
   
    
  function generateLTR(){
         for(var i=0;i<25;i++){
            var genX=0;
       
        
        var randY = 16*Math.round(Math.sin(leftBlock)+20)-(Math.floor(Math.random() * 10))*16;
        
        while(rightY!=randY){
            console.log("rightY=" + rightY);
            console.log("rightY=" + randY);
        genX=rightBlock;
        sand[genX] = new Array();
        rightBlock+=16;     
        let sprite=new PIXI.Sprite(PIXI.loader.resources["grass.png"].texture);
        sand[genX][rightY]=sprite;
            
        sand[genX][rightY].x=genX;
        var rightYToAdd=rightY;       
                 
        if(rightY<randY){
          sand[genX][rightY].y=rightY;
          rightY+=16;
        }
        else{
            sand[genX][rightY].y=rightY;
            rightY-=16;
        }
        
                 
        sand[genX][rightYToAdd].width=16;       
        sand[genX][rightYToAdd].height=16;
        container.addChild(sand[genX][rightYToAdd]);
            
            
            
        toDelete.push(sand[genX][rightYToAdd]);
        
        var toBottomY=rightYToAdd;
       while(toBottomY<700){
           sprite = new PIXI.Sprite(PIXI.loader.resources["g.png"].texture);
            toBottomY+=16;
            console.log('randY: ' + randY);
            sand[genX][toBottomY]=sprite;
            
            sand[genX][toBottomY].x=genX;
            sand[genX][toBottomY].y=toBottomY;
            sand[genX][toBottomY].width=16;       
            sand[genX][toBottomY].height=16;
           container.addChild(sand[genX][toBottomY]);
        toDelete.push(sand[genX][toBottomY]);
        }
                 
        
             }
        
        
        
    }
    
    app.stage.addChild(container);
    }
    
    
  function generateRTL(){
       
        var genX=0;
      /*
      
     toDelete.forEach(function(item) {
  item.visible=false;
});
      */
         for(var i=0;i<25;i++){
             
        
        
       
        var randY = 16*15-(Math.floor(Math.random() * 10))*16;
        //var randY=64;
        
      
             
        while(leftY!=randY){
            console.log("leftY=" + leftY);
            console.log("leftY=" + leftY);
        genX=leftBlock;
        sand[genX] = new Array();
        leftBlock-=16;  
        let sprite=new PIXI.Sprite(PIXI.loader.resources["grass.png"].texture);
        
        sand[genX][leftY]=sprite;
     
        sand[genX][leftY].x=genX;
        var leftYToAdd=leftY;       
                 
        if(leftY<randY){
          sand[genX][leftY].y=leftY;
          leftY+=16;
        }
        else{
            sand[genX][leftY].y=leftY;
            leftY-=16;
        }
        
                 
        sand[genX][leftYToAdd].width=16;       
        sand[genX][leftYToAdd].height=16;
        container.addChild(sand[genX][leftYToAdd]);
        toDelete.push(sand[genX][leftYToAdd]);
        var toBottomY=leftYToAdd;
        while(toBottomY<700){
            sprite = new PIXI.Sprite(PIXI.loader.resources["g.png"].texture);
            toBottomY+=16;
            console.log('randY: ' + randY);
            sand[genX][toBottomY]=sprite;
           
            sand[genX][toBottomY].x=genX;
            sand[genX][toBottomY].y=toBottomY;
            sand[genX][toBottomY].width=16;       
            sand[genX][toBottomY].height=16;
           container.addChild(sand[genX][toBottomY]);
        toDelete.push(sand[genX][toBottomY]);
        }
                 
        
             }
        
        
        
    }
    
   
    
    }
    
    
    
    
    function floatGrnd(){
       
        var genX=0;
      /*
      
     toDelete.forEach(function(item) {
  item.visible=false;
});
      */
         for(var i=0;i<200;i++){
             
        genX+=16;
        sand[genX] = new Array();
        
        
       
        var randY = 256;
      
        
          
        var sandBlock = new PIXI.Sprite(PIXI.loader.resources["grass.png"].texture);
             
        sand[genX][randY]=sandBlock;
        sand[genX][randY].x=genX;
        sand[genX][randY].y=randY;
        sand[genX][randY].width=16;       
        sand[genX][randY].height=16;
        container.addChild(sand[genX][randY]);
        console.log(sand[genX][randY]);
        console.log("block = " + genX + '|' + randY);
        console.log("coords = " + sand[genX][randY].x + "|" + sand[genX][randY].y);
             console.log('gen');
       
                 
        
             }
        
        
        
    
    
   
    
    }
    
    
    
    function checkPhysics(arr) {
      arr[1].y+=1;
    
      for(var i=-4;i<=2;i++){
                
                try{
                
                 
                 b = new Bump(PIXI);
                 let catVsBlocks = b.hit(
  arr[1], 
  sand[arr[1].x+(i*16)][arr[1].y+16], 
  true, false, false, 
  function(collision, platform){
      console.log("CATS COLLIDE " + i);
      console.log(collision);
      
      //cat.y-=7;
      
     if(i==-2|i==1){
         
         arr[1].y-=16
     };
      
      return true;
      
  }
                     
                     
);
                 
                  
               //collide(cat,sand[cat.x][cat.y+64]);
           }   
      catch {
         catFalling=true;
  }
            }
     
    
 }
    
    
    
    
    function keyboard(keyCode) {
  let key = {};
  key.code = keyCode;
  key.isDown = false;
  key.isUp = true;
  key.press = undefined;
  key.release = undefined;
  //The `downHandler`
  key.downHandler = event => {
    if (event.keyCode === key.code) {
      if (key.isUp && key.press) key.press();
      key.isDown = true;
      key.isUp = false;
    }
    event.preventDefault();
  };

  //The `upHandler`
  key.upHandler = event => {
    if (event.keyCode === key.code) {
      if (key.isDown && key.release) key.release();
      key.isDown = false;
      key.isUp = true;
    }
    event.preventDefault();
  };

  //Attach event listeners
  window.addEventListener(
    "keydown", key.downHandler.bind(key), false
  );
  window.addEventListener(
    "keyup", key.upHandler.bind(key), false
  );
  return key;
}
    
    
    let left = keyboard(37),
      up = keyboard(38),
      right = keyboard(39),
      down = keyboard(40);
    
    var cats=[];
    pers.y=0;
          
   let backCont = new PIXI.Container();
    var background = new PIXI.Sprite(PIXI.loader.resources["back.png"].texture);
    background.anchor.set(0);
    background.y=0;
    background.x=0;
    background.width=1000;
    background.height=600;
    backCont.addChild(background);
    app.stage.addChild(backCont);
    
          
    cat=new PIXI.Sprite(PIXI.loader.resources["cat.png"].texture);
    cat.anchor.set(0.5);
    
    cats[1]=new PIXI.Sprite(PIXI.loader.resources["cat2.png"].texture);
    cats[1].anchor.set(0.5);
    cats[1].y=0;
    cats[1].x=464+(16*20);
    cats[1].width=60;
    cats[1].height=50;
    container.addChild(cats[1]);
    app.stage.addChild(container);
    checkPhysics(cats);
    
          
          
    
    
    cat.y=0;
    container.y=200;
    cat.x=464;
    var roundedcatX=464;
    console.log(cat.getGlobalPosition());
    catY=160;
    cat.width=60;
    cat.height=50;
    
    
    container.addChild(cat);
    
    //container.addChild(cat);
    app.stage.addChild(container);
    
    
    generateRTL();
    generateLTR();
    //floatGrnd();
  
    
    
    function checkForEdges(side=""){
        
        
        
        
            
            if (side=="right"){
                
                
                
                
                if(container.x<((-1*rightBlock)+800)){
                    generateLTR();  
                }
                
               
            }
            else if (side=="left"){
                 if(container.x>((-1*leftBlock))){
                   generateRTL(); 
                }
            }
           
           
           
        
    }
    
    
    var moveRight=false;
    var moveLeft=false;
    
    right.press = () => {
        moveRight=true;
  };
    
    right.release = () =>{
      moveRight=false;  
    };
    
     left.press = () => {
        moveLeft=true;
  };
    
    left.release = () =>{
      moveLeft=false;  
    };


    app.stage.scale.set(0.8);
    //container.y=600;
    
  var sandBlock = new PIXI.Sprite(PIXI.loader.resources["s.jpg"].texture); 
  var catFalling=true;
    
    
    
 function collide() {
      for(var i=-4;i<=2;i++){
                
                try{
                
                 
                 b = new Bump(PIXI);
                 let catVsBlocks = b.hit(
  cat, 
  sand[roundedcatX+(i*16)][cat.y+16], 
  true, false, false, 
  function(collision, platform){
      console.log("collide at " + i);
      console.log(collision);
      catFalling=false;
      //cat.y-=7;
      
     if(i==-2|i==1){
         
         cat.y-=16
     };
      
      return true;
      
  }
                     
                     
);
                 
                  
               //collide(cat,sand[cat.x][cat.y+64]);
           }   
      catch {
         catFalling=true;
  }
            }
     
    
 }
         
        
         
    
  app.ticker.add(function() {
            if(catFalling)cat.y+=1;
      
            collide();
      
            checkPhysics(cats);
            
           
            
           
         

      
      
      
         

      
      
     
      
  
      
  if(moveRight){
      
      cat.x+=2;
      
      if ((cat.x%16)==0){
          console.log("rndCat++");
          roundedcatX+=16;
      }

      container.x-=2;
      checkForEdges('right');
      cat.scale.x = -0.3;
  }
      
  if(moveLeft){
     
      cat.x-=2;
      
       if ((cat.x%16)==0){
          roundedcatX=cat.x;
      }
      
      container.x+=2;
      console.log(cat.getGlobalPosition());
      cat.scale.x = 0.3;
      checkForEdges('left');
  }
      
      
       
  
  
  
   
});

    
    

}
    
    
    

    
    
    
    
    
    
    </script>
</body>
</html>