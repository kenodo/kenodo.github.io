<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>
<body>
    
    
    
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.7.1/pixi.min.js"></script>


<script>
  let app = new PIXI.Application({ 
    width: 800, 
    height: 600,                       
    antialias: true, 
    transparent: false, 
    resolution: 1,
    backgroundColor:0x51b1cd,
    roundPixels: true
  }
);

//Add the canvas that Pixi automatically created for you to the HTML document
document.body.appendChild(app.view);

//load an image and run the `setup` function when it's done
PIXI.loader
  .add("s.jpg")
  .load(setup);
    



//This `setup` function will run when the image has loaded
function setup() {
    var sand = [,];
    var leftBlock = 0;
    var leftY = 608;
    var rightY = 608;
    var rightBlock=0;
    
    let container = new PIXI.Container();
    var toDelete= [];
   
    
     function generateLTR(){
         for(var i=0;i<25;i++){
            var genX=0;
       
        var randY = 32*15-(Math.floor(Math.random() * 11))*32;
      
             
        while(rightY!=randY){
            console.log("rightY=" + rightY);
            console.log("rightY=" + randY);
        genX=rightBlock;
        rightBlock+=32;     
        
        sand[genX,rightY]=new PIXI.Sprite(PIXI.loader.resources["s.jpg"].texture);
        sand[genX,rightY].x=genX;
        var rightYToAdd=rightY;       
                 
        if(rightY<randY){
          sand[genX,rightY].y=rightY;
          rightY+=32;
        }
        else{
            sand[genX,rightY].y=rightY;
            rightY-=32;
        }
        
                 
        sand[genX,rightYToAdd].width=32;       
        sand[genX,rightYToAdd].height=32;
        container.addChild(sand[genX,rightYToAdd]);
        toDelete.push(sand[genX,rightYToAdd]);
        
        var toBottomY=rightYToAdd;
        while(toBottomY<700){
            toBottomY+=32;
            console.log('randY: ' + randY);
            sand[genX,toBottomY]=new PIXI.Sprite(PIXI.loader.resources["s.jpg"].texture);
            sand[genX,toBottomY].x=genX;
            sand[genX,toBottomY].y=toBottomY;
            sand[genX,toBottomY].width=32;       
            sand[genX,toBottomY].height=32;
           container.addChild(sand[genX,toBottomY]);
            toDelete.push(sand[genX,toBottomY]);
        }
                 
        
             }
        
        
        
    }
    
    app.stage.addChild(container);
    }
    
    
  function generateRTL(){
        var genX=0;
      
     toDelete.forEach(function(item) {
  item.visible=false;
});
      
         for(var i=0;i<25;i++){
        
       
        var randY = 32*15-(Math.floor(Math.random() * 11))*32;
      
             
        while(leftY!=randY){
            console.log("leftY=" + leftY);
            console.log("leftY=" + leftY);
        genX=leftBlock;
        leftBlock-=32;     
        
        sand[genX,leftY]=new PIXI.Sprite(PIXI.loader.resources["s.jpg"].texture);
        sand[genX,leftY].x=genX;
        var leftYToAdd=leftY;       
                 
        if(leftY<randY){
          sand[genX,leftY].y=leftY;
          leftY+=32;
        }
        else{
            sand[genX,leftY].y=leftY;
            leftY-=32;
        }
        
                 
        sand[genX,leftYToAdd].width=32;       
        sand[genX,leftYToAdd].height=32;
        container.addChild(sand[genX,leftYToAdd]);
        toDelete.push(sand[genX,leftYToAdd]);
        var toBottomY=leftYToAdd;
        while(toBottomY<700){
            toBottomY+=32;
            console.log('randY: ' + randY);
            sand[genX,toBottomY]=new PIXI.Sprite(PIXI.loader.resources["s.jpg"].texture);
            sand[genX,toBottomY].x=genX;
            sand[genX,toBottomY].y=toBottomY;
            sand[genX,toBottomY].width=32;       
            sand[genX,toBottomY].height=32;
           container.addChild(sand[genX,toBottomY]);
        toDelete.push(sand[genX,toBottomY]);
        }
                 
        
             }
        
        
        
    }
    
    app.stage.addChild(container);
    
    }
    
    
    function keyboard(keyCode) {
  let key = {};
  key.code = keyCode;
  key.isDown = false;
  key.isUp = true;
  key.press = undefined;
  key.release = undefined;
  //The `downHandler`
  key.downHandler = event => {
    if (event.keyCode === key.code) {
      if (key.isUp && key.press) key.press();
      key.isDown = true;
      key.isUp = false;
    }
    event.preventDefault();
  };

  //The `upHandler`
  key.upHandler = event => {
    if (event.keyCode === key.code) {
      if (key.isDown && key.release) key.release();
      key.isDown = false;
      key.isUp = true;
    }
    event.preventDefault();
  };

  //Attach event listeners
  window.addEventListener(
    "keydown", key.downHandler.bind(key), false
  );
  window.addEventListener(
    "keyup", key.upHandler.bind(key), false
  );
  return key;
}
    
    
    generateRTL();
    generateLTR();
    
    
    function checkForEdges(side=""){
        
        
        
        
            
            if (side=="right"){
                
                
                
                
                if(container.x<((-1*rightBlock)+800)){
                    generateLTR(); 
                }
                
               
            }
            else if (side=="left"){
                 if(container.x>((-1*leftBlock)-400)){
                    generateRTL(); 
                }
            }
           
           
           
        
    }


    
    
  app.ticker.add(function() {
  
      container.x+=11;
      console.log("container X = " + container.x);
      console.log("left = " + (leftBlock-800));
      
      
      checkForEdges('left');
       
  
  
  
   
});

    
    

}
    
    
    

    
    
    
    
    
    
    </script>
</body>
</html>